<!doctype html>
<meta charset="utf-8" />
<title>UE .sav â†’ JSON + Filter (Wasm, read-only)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="styles.css">

<h1>UE .sav â†’ JSON + Filter</h1>

<div class="status-bar">
  <div class="status-indicator">
    <span class="status-dot" id="statusDot"></span>
    <span id="statusText">Ready</span>
  </div>
  <div class="platform-badge" id="platformBadge">
    <span id="platformIcon">ğŸŒ</span>
    <span id="platformName">Browser</span>
  </div>
</div>

<div class="controls">
  <div class="control-row">
    <button class="btn btn-primary" id="pickFile">
      <span class="btn-icon">ğŸ“„</span> Pick .sav File
    </button>
    <button class="btn" id="pickDir" style="display: none;">
      <span class="btn-icon">ğŸ“</span> Pick Folder
    </button>
    <button class="btn" id="startWatch" style="display: none;">
      <span class="btn-icon">ğŸ‘ï¸</span> Start Watching
    </button>
    <button class="btn" id="rerunLast">
      <span class="btn-icon">ğŸ”„</span> Re-run Last
    </button>
  </div>
  <div class="control-row">
    <button class="btn" id="clearResults">
      <span class="btn-icon">ğŸ—‘ï¸</span> Clear Results
    </button>
    <button class="btn" id="toggleLog">
      <span class="btn-icon">ğŸ“‹</span> Toggle Log
    </button>
    <button class="btn" id="toggleConfig">
      <span class="btn-icon">âš™ï¸</span> Configure Filters
    </button>
  </div>
</div>

<div class="config-panel" id="configPanel" style="display: none;">
  <div class="config-header">
    <h3>Filter Configuration</h3>
    <span class="config-hint">Enter comma-separated attributes. Use * for wildcards (e.g., Fiery*Totem*Damage)</span>
    <span class="config-hint" style="display: block; margin-top: 5px;">These filters will be applied to all 3 attribute pools</span>
  </div>
  <div class="config-inputs">
    <div class="config-group">
      <label for="filterConfig">Target Attributes:</label>
      <textarea id="filterConfig" class="config-textarea" rows="3" placeholder="Fiery*Totem*Damage, Wisdom, MageryCriticalDamage, LifeStealChance, LifeStealAmount, CriticalChance"></textarea>
    </div>
  </div>
  <div class="config-actions">
    <button class="btn btn-primary" id="applyConfig">Apply & Re-scan</button>
    <button class="btn" id="resetConfig">Reset to Defaults</button>
  </div>
</div>

<!-- Single file input for .sav files -->
<input id="fileInput" type="file" accept=".sav" hidden />
<!-- Directory input for Chromium folder selection fallback -->
<input id="dirInput" type="file" webkitdirectory multiple hidden />

<div id="drop">
  <div class="drop-icon">ğŸ“¦</div>
  <div class="drop-text">Drop .sav files here or use the Pick button above</div>
</div>

<div class="results-container" id="resultsContainer"></div>

<pre id="log" style="display: none;"></pre>

<script type="module">
  // Import Wasm and filter
  import init, { to_json } from './uesave-wasm/pkg/uesave_wasm.js';
  import { analyzeUeSaveJson, DEFAULT_SLOT1, DEFAULT_SLOT2, DEFAULT_SLOT3 } from './dwarfFilter.js';

  // DOM elements
  const $log = document.getElementById('log');
  const $statusDot = document.getElementById('statusDot');
  const $statusText = document.getElementById('statusText');
  const $platformBadge = document.getElementById('platformBadge');
  const $platformIcon = document.getElementById('platformIcon');
  const $platformName = document.getElementById('platformName');
  const $resultsContainer = document.getElementById('resultsContainer');
  const $pickFile = document.getElementById('pickFile');
  const $pickDir = document.getElementById('pickDir');
  const $startWatch = document.getElementById('startWatch');
  const $rerunLast = document.getElementById('rerunLast');
  const $clearResults = document.getElementById('clearResults');
  const $toggleLog = document.getElementById('toggleLog');
  const $toggleConfig = document.getElementById('toggleConfig');
  const $configPanel = document.getElementById('configPanel');
  const $filterConfig = document.getElementById('filterConfig');
  const $applyConfig = document.getElementById('applyConfig');
  const $resetConfig = document.getElementById('resetConfig');
  const $fileInput = document.getElementById('fileInput');
  const $dirInput = document.getElementById('dirInput');
  const $drop = document.getElementById('drop');

  // State
  let dirHandle = null;
  let lastProcessedFiles = [];
  const seen = new Map();
  const hasDirPicker = 'showDirectoryPicker' in window;
  let timer = null;
  const itemResults = new Map(); // Store results by filename

  // Configuration state
  const defaultFilters = [
    "Fiery*Totem*Damage", "Wisdom", "MageryCriticalDamage", "MageryCriticalChance",
    "\bLifeSteal\b", "LifeStealAmount", "\bCriticalChance"
  ].join(", ");
  
  let currentFilterPatterns = [];

  // Convert string patterns to array (not regex, let the filter module handle that)
  function parseFilterString(filterStr) {
    if (!filterStr || filterStr.trim() === '') return [];
    
    return filterStr.split(',').map(pattern => pattern.trim()).filter(Boolean);
  }

  // Initialize configuration from defaults
  function initializeConfig() {
    currentFilterPatterns = parseFilterString(defaultFilters);
    $filterConfig.value = defaultFilters;
    log("âš™ï¸ Filters initialized:", currentFilterPatterns.join(", "));
  }

  // Platform detection and UI adjustment
  function detectPlatform() {
    const ua = navigator.userAgent;
    const isChromium = hasDirPicker;
    
    if (ua.includes('Safari') && !ua.includes('Chrome')) {
      $platformIcon.textContent = 'ğŸ§­';
      $platformName.textContent = 'Safari';
    } else if (ua.includes('Firefox')) {
      $platformIcon.textContent = 'ğŸ¦Š';
      $platformName.textContent = 'Firefox';
    } else if (isChromium) {
      $platformIcon.textContent = 'âš¡';
      $platformName.textContent = 'Chromium';
      // Show advanced features for Chromium
      $pickDir.style.display = 'inline-flex';
      $startWatch.style.display = 'inline-flex';
    }
    
    // Adjust help text based on browser
    if (!isChromium) {
      $drop.querySelector('.drop-text').textContent = 'Drop .sav files here or click "Pick .sav File" above';
    }
  }

  // Logging with timestamp
  function log(...args) {
    const time = new Date().toLocaleTimeString();
    $log.textContent += `[${time}] ${args.join(' ')}\n`;
    $log.scrollTop = $log.scrollHeight;
  }

  // Status updates
  function setStatus(text, type = 'ready') {
    $statusText.textContent = text;
    $statusDot.className = 'status-dot';
    if (type === 'active') $statusDot.classList.add('active');
    if (type === 'scanning') $statusDot.classList.add('scanning');
  }

  // Initialize
  async function initialize() {
    await init();
    log("âœ… Wasm module loaded");
    detectPlatform();
    initializeConfig();
    setStatus('Ready');
  }

  // Button handlers
  $pickFile.onclick = () => {
    $fileInput.click();
  };

  $pickDir.onclick = async () => {
    if (hasDirPicker) {
      try {
        dirHandle = await showDirectoryPicker({ mode: 'read' });
        log("ğŸ“ Folder granted (Chromium)");
        setStatus('Folder selected', 'active');
        
        // Auto-scan the folder once
        await scanOnce();
      } catch (e) {
        log("âŒ Pick canceled:", e?.message || e);
      }
    } else {
      // Fallback to directory input (shouldn't happen as button is hidden)
      $dirInput.click();
    }
  };

  // Single file selection handler
  $fileInput.onchange = async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    if (!/\.sav$/i.test(file.name)) {
      log("âš ï¸ Selected file is not a .sav file");
      setStatus('Invalid file type');
      return;
    }
    
    log(`ğŸ“„ Selected: ${file.name} (${(file.size/1024).toFixed(1)} KB)`);
    setStatus('Processing...', 'scanning');
    
    await processFiles([file], false);
    setStatus('Ready');
    
    // Clear the input so the same file can be selected again
    $fileInput.value = '';
  };

  // Directory input handler (fallback, shouldn't be used)
  $dirInput.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    const savFiles = files.filter(f => /\.sav$/i.test(f.name));
    
    if (savFiles.length === 0) {
      log("âš ï¸ No .sav files found in folder");
      setStatus('No .sav files found');
      return;
    }
    
    // Sort by last modified and take the most recent
    savFiles.sort((a, b) => b.lastModified - a.lastModified);
    const mostRecent = savFiles[0];
    
    log(`ğŸ“ Found ${savFiles.length} .sav files, using most recent: ${mostRecent.name}`);
    setStatus('Processing...', 'scanning');
    
    await processFiles([mostRecent], false);
    setStatus('Ready');
  };

  $startWatch.onclick = async () => {
    if (!hasDirPicker) return alert("Directory watching requires Chrome/Edge/Brave.");
    if (!dirHandle) {
      try {
        dirHandle = await showDirectoryPicker({ mode: 'read' });
      } catch {
        return;
      }
    }
    
    if (timer) {
      // Stop watching
      clearInterval(timer);
      timer = null;
      log("â¹ï¸ Stopped watching");
      setStatus('Ready');
      $startWatch.innerHTML = '<span class="btn-icon">ğŸ‘ï¸</span> Start Watching';
    } else {
      // Start watching
      log("ğŸ‘ï¸ Watching... (poll every 10s)");
      setStatus('Watching', 'active');
      $startWatch.innerHTML = '<span class="btn-icon">â¹ï¸</span> Stop Watching';
      timer = setInterval(() => scanOnce(), 10000);
      await scanOnce();
    }
  };

  $rerunLast.onclick = async () => {
    if (lastProcessedFiles.length === 0) {
      log("âš ï¸ No files to re-run");
      return;
    }
    log(`ğŸ”„ Re-running ${lastProcessedFiles.length} file(s)`);
    setStatus('Re-running...', 'scanning');
    
    // Force re-processing by clearing the seen cache for these files
    for (const file of lastProcessedFiles) {
      const key = (file.webkitRelativePath || file.name) || file.name;
      seen.delete(key);
    }
    
    await processFiles(lastProcessedFiles, false);
    setStatus('Ready');
  };

  $clearResults.onclick = () => {
    itemResults.clear();
    lastProcessedFiles = [];
    seen.clear();
    renderResults();
    log("ğŸ—‘ï¸ Results and file history cleared");
  };

  $toggleLog.onclick = () => {
    $log.style.display = $log.style.display === 'none' ? 'block' : 'none';
  };

  $toggleConfig.onclick = () => {
    $configPanel.style.display = $configPanel.style.display === 'none' ? 'block' : 'none';
  };

  $applyConfig.onclick = async () => {
    const newPatterns = parseFilterString($filterConfig.value);
    
    if (newPatterns.length === 0) {
      log("âš ï¸ No valid filters provided, keeping current configuration");
      return;
    }
    
    currentFilterPatterns = newPatterns;
    log("âš™ï¸ Filters updated:", currentFilterPatterns.join(", "));
    
    if (lastProcessedFiles.length > 0) {
      log("ğŸ”„ Re-scanning with new filters...");
      setStatus('Applying filters...', 'scanning');
      await processFiles(lastProcessedFiles, true);
      setStatus('Ready');
    } else {
      itemResults.clear();
      renderResults();
    }
    
    $configPanel.style.display = 'none';
  };

  $resetConfig.onclick = async () => {
    $filterConfig.value = defaultFilters;
    currentFilterPatterns = parseFilterString(defaultFilters);
    
    log("ğŸ”„ Filters reset to defaults");
    
    if (lastProcessedFiles.length > 0) {
      log("ğŸ”„ Re-scanning with default filters...");
      setStatus('Applying default filters...', 'scanning');
      await processFiles(lastProcessedFiles, true);
      setStatus('Ready');
    } else {
      itemResults.clear();
      renderResults();
    }
    
    $configPanel.style.display = 'none';
  };

  // Drag & drop
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    $drop.addEventListener(eventName, (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
  });

  ['dragenter', 'dragover'].forEach(eventName => {
    $drop.addEventListener(eventName, () => $drop.classList.add('drag-over'));
  });

  ['dragleave', 'drop'].forEach(eventName => {
    $drop.addEventListener(eventName, () => $drop.classList.remove('drag-over'));
  });
  
  $drop.addEventListener('drop', async (e) => {
    $drop.classList.remove('drag-over');
    const files = [...e.dataTransfer.files].filter(f => /\.sav$/i.test(f.name));
    if (!files.length) {
      log("âš ï¸ No .sav files in drop");
      return;
    }
    log(`ğŸ“¦ Processing ${files.length} dropped file(s)`);
    setStatus('Processing dropped files...', 'scanning');
    
    await processFiles(files, false);
    setStatus('Ready');
  });

  // Scan once (for folder watching)
  async function scanOnce() {
    if (!hasDirPicker || !dirHandle) return;
    
    setStatus('Scanning...', 'scanning');
    
    const files = [];
    for await (const [name, handle] of dirHandle.entries()) {
      if (!/\.sav$/i.test(name)) continue;
      const file = await handle.getFile();
      files.push(file);
    }
    
    if (!files.length) {
      log("âš ï¸ No .sav files found");
      setStatus('No files found');
      return;
    }
    
    // Process only changed files
    const changedFiles = [];
    for (const file of files) {
      const key = file.name;
      const stat = { size: file.size, mtime: file.lastModified };
      const prev = seen.get(key);
      
      if (!prev || prev.size !== stat.size || prev.mtime !== stat.mtime) {
        changedFiles.push(file);
      }
    }
    
    if (changedFiles.length > 0) {
      log(`ğŸ“‚ Found ${changedFiles.length} new/changed file(s)`);
      await processFiles(changedFiles, false);
    } else {
      log("â­ï¸ No changes detected");
    }
    
    setStatus('Watching', 'active');
  }

  // Process files
  async function processFiles(files, clearPrevious = false) {
    if (clearPrevious) {
      itemResults.clear();
    }
    
    if (clearPrevious) {
      lastProcessedFiles = files;
    } else {
      for (const file of files) {
        const existingIndex = lastProcessedFiles.findIndex(f => f.name === file.name);
        if (existingIndex >= 0) {
          lastProcessedFiles[existingIndex] = file;
        } else {
          lastProcessedFiles.push(file);
        }
      }
    }
    
    for (const f of files) {
      const key = (f.webkitRelativePath || f.name) || f.name;
      const stat = { size: f.size, mtime: f.lastModified };
      seen.set(key, stat);

      log(`ğŸ“„ Converting: ${key} (${(f.size/1024).toFixed(1)} KB)`);
      const bytes = new Uint8Array(await f.arrayBuffer());

      let json;
      try {
        json = to_json(bytes);
      } catch (e) {
        console.error(e);
        log(`âŒ Conversion failed: ${e.message || e}`);
        continue;
      }

      const filterOptions = {
        slot1: currentFilterPatterns,
        slot2: currentFilterPatterns,
        slot3: currentFilterPatterns,
        includeWeapons: true,
        showClose: true,
        closeMinTotal: 2,
        debug: false,
      };

      const { hits, close, totalItems } = analyzeUeSaveJson(json, filterOptions);

      itemResults.set(key, { 
        hits, 
        close, 
        totalItems, 
        timestamp: Date.now(),
        filters: [...currentFilterPatterns]
      });
      
      log(`âœ… Found ${hits.length} matches, ${close.length} near-misses from ${totalItems} items`);
      
      // Download JSON
      downloadText(json, f.name.replace(/\.sav$/i, ".json"));
      
      // Play sound if we found matches
      if (hits.length > 0) {
        try {
          await playSound();
        } catch {}
      }
    }
    
    renderResults();
  }

  // Render results as cards
  function renderResults() {
    if (itemResults.size === 0) {
      $resultsContainer.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">ğŸ”­</div>
          <div>No results yet. Select a .sav file or drop one here to begin.</div>
        </div>
      `;
      return;
    }

    let html = '';
    
    html += `
      <div class="filter-display">
        <strong>Active Filters:</strong> ${currentFilterPatterns.join(", ")}
        <div style="margin-top: 0.5rem; font-size: 0.9em; color: var(--text-secondary);">
          ${itemResults.size} file(s) processed | ${lastProcessedFiles.length} file(s) in memory
        </div>
      </div>
    `;
    
    const sortedResults = Array.from(itemResults.entries()).sort((a, b) => 
      b[1].timestamp - a[1].timestamp
    );
    
    for (const [filename, data] of sortedResults) {
      const { hits, close, totalItems, timestamp } = data;
      const timeStr = new Date(timestamp).toLocaleTimeString();
      
      if (hits.length > 0) {
        html += `
          <div class="results-section">
            <div class="section-header">
              <span>âœ…</span>
              <span>Matches - ${filename}</span>
              <span style="margin-left: auto; font-size: 0.8rem; color: var(--text-secondary);">
                ${hits.length} of ${totalItems} items | ${timeStr}
              </span>
            </div>
            <div class="item-grid">
              ${hits.map(item => createItemCard(item, 'hit')).join('')}
            </div>
          </div>
        `;
      }
      
      if (close.length > 0) {
        html += `
          <div class="results-section">
            <div class="section-header">
              <span>âš¡</span>
              <span>Near Misses - ${filename}</span>
              <span style="margin-left: auto; font-size: 0.8rem; color: var(--text-secondary);">
                ${close.length} of ${totalItems} items | ${timeStr}
              </span>
            </div>
            <div class="item-grid">
              ${close.map(item => createItemCard(item, 'close')).join('')}
            </div>
          </div>
        `;
      }
      
      if (hits.length === 0 && close.length === 0) {
        html += `
          <div class="results-section">
            <div class="section-header">
              <span>ğŸ“­</span>
              <span>${filename}</span>
              <span style="margin-left: auto; font-size: 0.8rem; color: var(--text-secondary);">
                0 matches from ${totalItems} items | ${timeStr}
              </span>
            </div>
            <div style="padding: 1rem; text-align: center; color: var(--text-secondary);">
              No items matched the current filters
            </div>
          </div>
        `;
      }
    }
    
    $resultsContainer.innerHTML = html;
  }

  // Create item card HTML
  function createItemCard(item, type) {
    const scoreClass = (val) => val >= 2 ? 'good' : val === 1 ? 'partial' : 'zero';
    
    const isMatch = (attr) => {
      return currentFilterPatterns.some(pattern => {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
        return regex.test(attr);
      });
    };
    
    const pool1Attrs = item.item?.pool1_attributes || [];
    const pool2Attrs = item.item?.pool2_attributes || [];
    const pool3Attrs = item.item?.pool3_attributes || [];
    const inherentAttrs = item.item?.inherent_attributes || [];
    
    let poolsHtml = '';
    
    if (pool1Attrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Pool 1 (${pool1Attrs.length})</div>
          <div class="pool-attributes">
            ${pool1Attrs.map(a => 
              `<span class="attribute-pill${isMatch(a) ? ' match' : ''}">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    if (pool2Attrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Pool 2 (${pool2Attrs.length})</div>
          <div class="pool-attributes">
            ${pool2Attrs.map(a => 
              `<span class="attribute-pill${isMatch(a) ? ' match' : ''}">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    if (pool3Attrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Pool 3 (${pool3Attrs.length})</div>
          <div class="pool-attributes">
            ${pool3Attrs.map(a => 
              `<span class="attribute-pill${isMatch(a) ? ' match' : ''}">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    if (inherentAttrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Inherent (${inherentAttrs.length})</div>
          <div class="pool-attributes">
            ${inherentAttrs.map(a => 
              `<span class="attribute-pill inherent">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    const attrHtml = poolsHtml ? `<div class="item-attributes">${poolsHtml}</div>` : '';
    
    return `
      <div class="item-card ${type}">
        <div class="item-header">
          <div class="item-name">${item.name}</div>
          <div class="item-type">${item.type}</div>
        </div>
        <div class="item-scores">
          <div class="score-badge">
            <div class="score-label">Pool 1</div>
            <div class="score-value ${scoreClass(item.s1)}">${item.s1}</div>
          </div>
          <div class="score-badge">
            <div class="score-label">Pool 2</div>
            <div class="score-value ${scoreClass(item.s2)}">${item.s2}</div>
          </div>
          <div class="score-badge">
            <div class="score-label">Pool 3</div>
            <div class="score-value ${scoreClass(item.s3)}">${item.s3}</div>
          </div>
        </div>
        ${attrHtml}
      </div>
    `;
  }

  // Download helper
  function downloadText(text, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], { type: "application/json" }));
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // Sound notification
  async function playSound() {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.type = "sine";
    osc.frequency.value = 760;
    gain.gain.value = 0.1;
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
    
    setTimeout(() => {
      osc.stop();
      ctx.close();
    }, 150);
  }

  // Initialize on load
  initialize();
</script>