<!doctype html>
<meta charset="utf-8" />
<title>UE .sav → JSON + Filter (Wasm, read-only)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="stylesheet" href="styles.css">

<h1>UE .sav → JSON + Filter</h1>

<div class="status-bar">
  <div class="status-indicator">
    <span class="status-dot" id="statusDot"></span>
    <span id="statusText">Ready</span>
  </div>
  <div class="platform-badge" id="platformBadge">
    <span id="platformIcon">🌐</span>
    <span id="platformName">Browser</span>
  </div>
</div>

<div class="controls">
  <div class="control-row">
    <button class="btn btn-primary" id="pickDir">
      <span class="btn-icon">📁</span> Pick Folder
    </button>
    <button class="btn" id="startWatch">
      <span class="btn-icon">👁️</span> Start Watching
    </button>
    <button class="btn" id="scanNow">
      <span class="btn-icon">🔍</span> Scan Now
    </button>
    <button class="btn" id="rerunLast">
      <span class="btn-icon">🔄</span> Re-run Last
    </button>
  </div>
  <div class="control-row">
    <button class="btn" id="clearResults">
      <span class="btn-icon">🗑️</span> Clear Results
    </button>
    <button class="btn" id="toggleLog">
      <span class="btn-icon">📋</span> Toggle Log
    </button>
    <button class="btn" id="toggleConfig">
      <span class="btn-icon">⚙️</span> Configure Filters
    </button>
  </div>
</div>

<div class="config-panel" id="configPanel" style="display: none;">
  <div class="config-header">
    <h3>Filter Configuration</h3>
    <span class="config-hint">Enter comma-separated attributes. Use * for wildcards (e.g., Fiery*Totem*Damage)</span>
    <span class="config-hint" style="display: block; margin-top: 5px;">These filters will be applied to all 3 attribute pools</span>
  </div>
  <div class="config-inputs">
    <div class="config-group">
      <label for="filterConfig">Target Attributes:</label>
      <textarea id="filterConfig" class="config-textarea" rows="3" placeholder="Fiery*Totem*Damage, Wisdom, MageryCriticalDamage, LifeStealChance, LifeStealAmount, CriticalChance"></textarea>
    </div>
  </div>
  <div class="config-actions">
    <button class="btn btn-primary" id="applyConfig">Apply & Re-scan</button>
    <button class="btn" id="resetConfig">Reset to Defaults</button>
  </div>
</div>

<input id="fileInput" type="file" webkitdirectory multiple hidden />

<div id="drop">
  <div class="drop-icon">📦</div>
  <div class="drop-text">Drop .sav files here</div>
</div>

<div class="results-container" id="resultsContainer"></div>

<pre id="log" style="display: none;"></pre>

<script type="module">
  // Import Wasm and filter
  import init, { to_json } from './uesave-wasm/pkg/uesave_wasm.js';
  import { analyzeUeSaveJson, DEFAULT_SLOT1, DEFAULT_SLOT2, DEFAULT_SLOT3 } from './dwarfFilter.js';

  // DOM elements
  const $log = document.getElementById('log');
  const $statusDot = document.getElementById('statusDot');
  const $statusText = document.getElementById('statusText');
  const $platformBadge = document.getElementById('platformBadge');
  const $platformIcon = document.getElementById('platformIcon');
  const $platformName = document.getElementById('platformName');
  const $resultsContainer = document.getElementById('resultsContainer');
  const $pickDir = document.getElementById('pickDir');
  const $startWatch = document.getElementById('startWatch');
  const $scanNow = document.getElementById('scanNow');
  const $rerunLast = document.getElementById('rerunLast');
  const $clearResults = document.getElementById('clearResults');
  const $toggleLog = document.getElementById('toggleLog');
  const $toggleConfig = document.getElementById('toggleConfig');
  const $configPanel = document.getElementById('configPanel');
  const $filterConfig = document.getElementById('filterConfig');
  const $applyConfig = document.getElementById('applyConfig');
  const $resetConfig = document.getElementById('resetConfig');
  const $input = document.getElementById('fileInput');
  const $drop = document.getElementById('drop');

  // State
  let dirHandle = null;
  let fileListSnapshot = [];
  let lastProcessedFiles = [];
  const seen = new Map();
  const hasDirPicker = 'showDirectoryPicker' in window;
  let timer = null;
  const itemResults = new Map(); // Store results by filename

  // Configuration state
  const defaultFilters = [
    "Fiery*Totem*Damage", "Wisdom", "MageryCriticalDamage", 
    "LifeStealChance", "LifeStealAmount", "CriticalChance"
  ].join(", ");
  
  let currentFilterPatterns = [];

  // Convert string patterns to array (not regex, let the filter module handle that)
  function parseFilterString(filterStr) {
    if (!filterStr || filterStr.trim() === '') return [];
    
    return filterStr.split(',').map(pattern => pattern.trim()).filter(Boolean);
  }

  // Initialize configuration from defaults
  function initializeConfig() {
    currentFilterPatterns = parseFilterString(defaultFilters);
    $filterConfig.value = defaultFilters;
    log("⚙️ Filters initialized:", currentFilterPatterns.join(", "));
  }

  // Platform detection
  function detectPlatform() {
    const ua = navigator.userAgent;
    if (ua.includes('Safari') && !ua.includes('Chrome')) {
      $platformIcon.textContent = '🧭';
      $platformName.textContent = 'Safari';
      $startWatch.classList.add('hidden');
    } else if (ua.includes('Firefox')) {
      $platformIcon.textContent = '🦊';
      $platformName.textContent = 'Firefox';
      $startWatch.classList.add('hidden');
    } else if (hasDirPicker) {
      $platformIcon.textContent = '📷';
      $platformName.textContent = 'Chromium';
    }
  }

  // Logging with timestamp
  function log(...args) {
    const time = new Date().toLocaleTimeString();
    $log.textContent += `[${time}] ${args.join(' ')}\n`;
    $log.scrollTop = $log.scrollHeight;
  }

  // Status updates
  function setStatus(text, type = 'ready') {
    $statusText.textContent = text;
    $statusDot.className = 'status-dot';
    if (type === 'active') $statusDot.classList.add('active');
    if (type === 'scanning') $statusDot.classList.add('scanning');
  }

  // Initialize
  async function initialize() {
    await init();
    log("✅ Wasm module loaded");
    detectPlatform();
    initializeConfig();
    setStatus('Ready');
  }

  // Button handlers
  $pickDir.onclick = async () => {
    if (hasDirPicker) {
      try {
        dirHandle = await showDirectoryPicker({ mode: 'read' });
        log("📁 Folder granted (Chromium)");
        setStatus('Folder selected', 'active');
      } catch (e) {
        log("❌ Pick canceled:", e?.message || e);
      }
    } else {
      $input.click();
    }
  };

  $input.onchange = async (e) => {
    fileListSnapshot = Array.from(e.target.files || []);
    log(`📁 Snapshot selected: ${fileListSnapshot.length} files`);
    setStatus(`${fileListSnapshot.length} files selected`, 'active');
    
    // Auto-process .sav files if any were selected
    const savs = fileListSnapshot.filter(f => /\.sav$/i.test(f.name));
    if (savs.length > 0) {
      log(`🔍 Auto-processing ${savs.length} .sav file(s)`);
      setStatus('Processing...', 'scanning');
      await processFiles(savs, false); // Don't clear previous results
      setStatus('Ready');
    }
  };

  $startWatch.onclick = async () => {
    if (!hasDirPicker) return alert("Directory watching requires Chrome/Edge/Brave.");
    if (!dirHandle) {
      try {
        dirHandle = await showDirectoryPicker({ mode: 'read' });
      } catch {
        return;
      }
    }
    if (timer) clearInterval(timer);
    log("👁️ Watching... (poll every 10s)");
    setStatus('Watching', 'active');
    timer = setInterval(() => scanOnce(), 10000);
    await scanOnce();
  };

  $scanNow.onclick = scanOnce;
  
  $rerunLast.onclick = async () => {
    if (lastProcessedFiles.length === 0) {
      log("⚠️ No files to re-run");
      return;
    }
    log(`🔄 Re-running ${lastProcessedFiles.length} file(s)`);
    setStatus('Re-running...', 'scanning');
    
    // Force re-processing by clearing the seen cache for these files
    for (const file of lastProcessedFiles) {
      const key = (file.webkitRelativePath || file.name) || file.name;
      seen.delete(key);
    }
    
    await processFiles(lastProcessedFiles, false); // Don't clear previous results
    setStatus('Ready');
  };

  $clearResults.onclick = () => {
    itemResults.clear();
    lastProcessedFiles = [];
    seen.clear();
    renderResults();
    log("🗑️ Results and file history cleared");
  };

  $toggleLog.onclick = () => {
    $log.style.display = $log.style.display === 'none' ? 'block' : 'none';
  };

  $toggleConfig.onclick = () => {
    $configPanel.style.display = $configPanel.style.display === 'none' ? 'block' : 'none';
  };

  $applyConfig.onclick = async () => {
    // Parse and apply configuration
    const newPatterns = parseFilterString($filterConfig.value);
    
    if (newPatterns.length === 0) {
      log("⚠️ No valid filters provided, keeping current configuration");
      return;
    }
    
    currentFilterPatterns = newPatterns;
    log("⚙️ Filters updated:", currentFilterPatterns.join(", "));
    
    // Re-run if we have files (clear previous since filters changed)
    if (lastProcessedFiles.length > 0) {
      log("🔄 Re-scanning with new filters...");
      setStatus('Applying filters...', 'scanning');
      await processFiles(lastProcessedFiles, true); // Clear previous results
      setStatus('Ready');
    } else {
      // Clear results even if no files to re-run
      itemResults.clear();
      renderResults();
    }
    
    $configPanel.style.display = 'none';
  };

  $resetConfig.onclick = async () => {
    $filterConfig.value = defaultFilters;
    currentFilterPatterns = parseFilterString(defaultFilters);
    
    log("🔄 Filters reset to defaults");
    
    // Re-run if we have files (clear previous since filters changed)
    if (lastProcessedFiles.length > 0) {
      log("🔄 Re-scanning with default filters...");
      setStatus('Applying default filters...', 'scanning');
      await processFiles(lastProcessedFiles, true); // Clear previous results
      setStatus('Ready');
    } else {
      // Clear results even if no files to re-run
      itemResults.clear();
      renderResults();
    }
    
    $configPanel.style.display = 'none';
  };

  // Drag & drop
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    $drop.addEventListener(eventName, (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
  });

  ['dragenter', 'dragover'].forEach(eventName => {
    $drop.addEventListener(eventName, () => $drop.classList.add('drag-over'));
  });

  ['dragleave', 'drop'].forEach(eventName => {
    $drop.addEventListener(eventName, () => $drop.classList.remove('drag-over'));
  });
  
  $drop.addEventListener('drop', async (e) => {
    $drop.classList.remove('drag-over');
    const files = [...e.dataTransfer.files].filter(f => /\.sav$/i.test(f.name));
    if (!files.length) {
      log("⚠️ No .sav files in drop");
      return;
    }
    log(`📦 Processing ${files.length} dropped file(s)`);
    setStatus('Processing dropped files...', 'scanning');
    
    await processFiles(files, false); // Don't clear previous results
    setStatus('Ready');
  });

  // Scan once
  async function scanOnce() {
    setStatus('Scanning...', 'scanning');
    
    if (hasDirPicker && dirHandle) {
      const files = [];
      for await (const [name, handle] of dirHandle.entries()) {
        if (!/\.sav$/i.test(name)) continue;
        const file = await handle.getFile();
        files.push(file);
      }
      if (!files.length) {
        log("⚠️ No .sav files found");
        setStatus('No files found');
      } else {
        await processFiles(files, false); // Don't clear previous results
      }
    } else {
      if (!fileListSnapshot.length) {
        log("⚠️ No snapshot yet");
        setStatus('No files selected');
        return;
      }
      const savs = fileListSnapshot.filter(f => /\.sav$/i.test(f.name));
      await processFiles(savs, false); // Don't clear previous results
    }
    
    setStatus('Ready');
  }

  // Process files
  async function processFiles(files, clearPrevious = false) {
    // Clear previous results if requested (e.g., when filters change)
    if (clearPrevious) {
      itemResults.clear();
    }
    
    // Update lastProcessedFiles - accumulate unless clearing
    if (clearPrevious) {
      lastProcessedFiles = files;
    } else {
      // Add new files or update existing ones
      for (const file of files) {
        const existingIndex = lastProcessedFiles.findIndex(f => f.name === file.name);
        if (existingIndex >= 0) {
          lastProcessedFiles[existingIndex] = file;
        } else {
          lastProcessedFiles.push(file);
        }
      }
    }
    
    for (const f of files) {
      const key = (f.webkitRelativePath || f.name) || f.name;
      const stat = { size: f.size, mtime: f.lastModified };
      const prev = seen.get(key);
      
      if (prev && prev.size === stat.size && prev.mtime === stat.mtime) {
        log(`⏭️ Skipping unchanged: ${key}`);
        continue;
      }
      seen.set(key, stat);

      log(`📄 Converting: ${key} (${(f.size/1024).toFixed(1)} KB)`);
      const bytes = new Uint8Array(await f.arrayBuffer());

      let json;
      try {
        json = to_json(bytes);
      } catch (e) {
        console.error(e);
        log(`❌ Conversion failed: ${e.message || e}`);
        continue;
      }

      // Prepare filter options - use the same patterns for all 3 slots
      const filterOptions = {
        slot1: currentFilterPatterns,
        slot2: currentFilterPatterns,
        slot3: currentFilterPatterns,
        includeWeapons: true,
        showClose: true,
        closeMinTotal: 2,
        debug: false,
      };

      // Analyze with current filters
      const { hits, close, totalItems } = analyzeUeSaveJson(json, filterOptions);

      // Store results - this will update if file already exists
      itemResults.set(key, { 
        hits, 
        close, 
        totalItems, 
        timestamp: Date.now(),
        filters: [...currentFilterPatterns] // Store which filters were used
      });
      
      log(`✅ Found ${hits.length} matches, ${close.length} near-misses from ${totalItems} items`);
      
      // Download JSON
      downloadText(json, f.name.replace(/\.sav$/i, ".json"));
      
      // Play sound if we found matches
      if (hits.length > 0) {
        try {
          await playSound();
        } catch {}
      }
    }
    
    renderResults();
  }

  // Render results as cards
  function renderResults() {
    if (itemResults.size === 0) {
      $resultsContainer.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">🔭</div>
          <div>No results yet. Drop files or scan a folder to begin.</div>
        </div>
      `;
      return;
    }

    let html = '';
    
    // Add current filter display
    html += `
      <div class="filter-display" style="margin-bottom: 1rem; padding: 0.75rem; background: var(--surface-secondary); border-radius: 8px;">
        <strong>Active Filters:</strong> ${currentFilterPatterns.join(", ")}
        <div style="margin-top: 0.5rem; font-size: 0.9em; color: var(--text-secondary);">
          ${itemResults.size} file(s) processed | ${lastProcessedFiles.length} file(s) in memory
        </div>
      </div>
    `;
    
    // Sort by timestamp (most recent first)
    const sortedResults = Array.from(itemResults.entries()).sort((a, b) => 
      b[1].timestamp - a[1].timestamp
    );
    
    for (const [filename, data] of sortedResults) {
      const { hits, close, totalItems, timestamp } = data;
      const timeStr = new Date(timestamp).toLocaleTimeString();
      
      if (hits.length > 0) {
        html += `
          <div class="results-section">
            <div class="section-header">
              <span>✅</span>
              <span>Matches - ${filename}</span>
              <span style="margin-left: auto; font-size: 0.8rem; color: var(--text-secondary);">
                ${hits.length} of ${totalItems} items | ${timeStr}
              </span>
            </div>
            <div class="item-grid">
              ${hits.map(item => createItemCard(item, 'hit')).join('')}
            </div>
          </div>
        `;
      }
      
      if (close.length > 0) {
        html += `
          <div class="results-section">
            <div class="section-header">
              <span>⚡</span>
              <span>Near Misses - ${filename}</span>
              <span style="margin-left: auto; font-size: 0.8rem; color: var(--text-secondary);">
                ${close.length} of ${totalItems} items | ${timeStr}
              </span>
            </div>
            <div class="item-grid">
              ${close.map(item => createItemCard(item, 'close')).join('')}
            </div>
          </div>
        `;
      }
      
      // Show message if no results
      if (hits.length === 0 && close.length === 0) {
        html += `
          <div class="results-section">
            <div class="section-header">
              <span>📭</span>
              <span>${filename}</span>
              <span style="margin-left: auto; font-size: 0.8rem; color: var(--text-secondary);">
                0 matches from ${totalItems} items | ${timeStr}
              </span>
            </div>
            <div style="padding: 1rem; text-align: center; color: var(--text-secondary);">
              No items matched the current filters
            </div>
          </div>
        `;
      }
    }
    
    $resultsContainer.innerHTML = html;
  }

  // Create item card HTML
  function createItemCard(item, type) {
    const scoreClass = (val) => val >= 2 ? 'good' : val === 1 ? 'partial' : 'zero';
    
    // Helper to check if attribute matches filters
    const isMatch = (attr) => {
      return currentFilterPatterns.some(pattern => {
        const regex = new RegExp(pattern.replace(/\*/g, '.*'), 'i');
        return regex.test(attr);
      });
    };
    
    // Build pool attributes HTML
    const pool1Attrs = item.item?.pool1_attributes || [];
    const pool2Attrs = item.item?.pool2_attributes || [];
    const pool3Attrs = item.item?.pool3_attributes || [];
    const inherentAttrs = item.item?.inherent_attributes || [];
    
    let poolsHtml = '';
    
    // Pool 1
    if (pool1Attrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Pool 1 (${pool1Attrs.length})</div>
          <div class="pool-attributes">
            ${pool1Attrs.map(a => 
              `<span class="attribute-pill${isMatch(a) ? ' match' : ''}">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    // Pool 2
    if (pool2Attrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Pool 2 (${pool2Attrs.length})</div>
          <div class="pool-attributes">
            ${pool2Attrs.map(a => 
              `<span class="attribute-pill${isMatch(a) ? ' match' : ''}">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    // Pool 3
    if (pool3Attrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Pool 3 (${pool3Attrs.length})</div>
          <div class="pool-attributes">
            ${pool3Attrs.map(a => 
              `<span class="attribute-pill${isMatch(a) ? ' match' : ''}">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    // Inherent attributes (if any)
    if (inherentAttrs.length > 0) {
      poolsHtml += `
        <div class="attribute-pool">
          <div class="pool-header">Inherent (${inherentAttrs.length})</div>
          <div class="pool-attributes">
            ${inherentAttrs.map(a => 
              `<span class="attribute-pill inherent">${a}</span>`
            ).join('')}
          </div>
        </div>
      `;
    }
    
    const attrHtml = poolsHtml ? `<div class="item-attributes">${poolsHtml}</div>` : '';
    
    return `
      <div class="item-card ${type}">
        <div class="item-header">
          <div class="item-name">${item.name}</div>
          <div class="item-type">${item.type}</div>
        </div>
        <div class="item-scores">
          <div class="score-badge">
            <div class="score-label">Pool 1</div>
            <div class="score-value ${scoreClass(item.s1)}">${item.s1}</div>
          </div>
          <div class="score-badge">
            <div class="score-label">Pool 2</div>
            <div class="score-value ${scoreClass(item.s2)}">${item.s2}</div>
          </div>
          <div class="score-badge">
            <div class="score-label">Pool 3</div>
            <div class="score-value ${scoreClass(item.s3)}">${item.s3}</div>
          </div>
        </div>
        ${attrHtml}
      </div>
    `;
  }

  // Download helper
  function downloadText(text, filename) {
    const a = document.createElement('a');
    a.href = URL.createObjectURL(new Blob([text], { type: "application/json" }));
    a.download = filename;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  // Sound notification
  async function playSound() {
    const ctx = new AudioContext();
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    
    osc.type = "sine";
    osc.frequency.value = 760;
    gain.gain.value = 0.1;
    
    osc.connect(gain);
    gain.connect(ctx.destination);
    
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
    
    setTimeout(() => {
      osc.stop();
      ctx.close();
    }, 150);
  }

  // Initialize on load
  initialize();
</script>